// Common to have both config and helpers.js files in projects that you create
// Goal of this module is to contain a few functions that are reused over and over. This module provides a central place for all of them

import 'regenerator-runtime/runtime';

// Imports from config
import { TIMEOUT_SEC } from './config.js';

// Timeout function
// Returns a promise that will reject after a certain number of seconds. Important to include timeouts like this w/ api calls to combat really slow internet connections
const timeout = function (s) {
  return new Promise(function (_, reject) {
    setTimeout(function () {
      reject(new Error(`Request took too long! Timeout after ${s} second`));
    }, s * 1000);
  });
};

// Async function that will do the fetching and conversion to JSON in 1 step
export const getJSON = async function (url) {
  try {
    const res = await Promise.race([fetch(url), timeout(TIMEOUT_SEC)]); // Someone reading will see this is a config setting cz of capitals
    const data = await res.json();

    if (!res.ok)
      throw new Error(
        `Issue getting data from API=> ${data.message} (${res.status})`
      );
    return data;
  } catch (err) {
    throw err; //Throw error cz we want to handle the error in the model.js where this function is called. Doing this will cause the promise being returned from getJSON to be rejected in case of a 400 error -> usually it will returned fufilled w/ an error
    // Propogating the error down by re-throwing the error
  }
};

// Sending data to an API.
// Using a POST request instead of a GET request (get request automatically generated by passing url into fetch). POST requests require an additional object of options to be passed in as an arg
export const sendJSON = async function (url, uploadData) {
  try {
    const sendPromise = fetch(url, {
      method: 'POST',
      // Header are sinppets of text that provides info on the request itself. Many are standard except the following
      headers: { 'Content-Type': 'application/json' }, // Content-Type tells the api we are sending data in the JSON format. Makes it possible for the api to correctly accept the data and create a new enrty
      body: JSON.stringify(uploadData), // This is the 'payload' (the data that will be sent. Need to convert to json. Passed into function)
    });

    const res = await Promise.race([sendPromise, timeout(TIMEOUT_SEC)]); // Someone reading will see this is a config setting cz of capitals
    const data = await res.json(); // awaiting any data that will come back cz the forkify api will return the data we just sent

    if (!res.ok)
      throw new Error(
        `Issue getting data from API=> ${data.message} (${res.status})`
      );
    return data;
  } catch (err) {
    throw err; //Throw error cz we want to handle the error in the model.js where this function is called. Doing this will cause the promise being returned from getJSON to be rejected in case of a 400 error -> usually it will returned fufilled w/ an error
    // Propogating the error down by re-throwing the error
  }
};

// Joining the above 2 into a single function
export const getAJAX = async function (url, uploadData = undefined) {
  try {
    const fetchPromise = uploadData
      ? fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(uploadData),
        })
      : fetch(url);

    const data = await res.json();

    if (!res.ok)
      throw new Error(
        `Issue getting data from API=> ${data.message} (${res.status})`
      );
    return data;
  } catch (err) {
    throw err;
  }
};
